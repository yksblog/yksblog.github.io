<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>前端必知必会</title>
<meta name="generator" content="Org Mode" />
<link rel='shortcut icon' href='https://yangk.net/org_themes/favicon.ico' type='image/x-icon' />
           <link rel='stylesheet' href='https://yangk.net/org_themes/style.css' type='text/css'  />
           <script type='module' src='https://yangk.net/org_themes/main.js' defer></script>
<meta name="card" content="">
</head>
<body>
<div id="content" class="content">
<h1 class="title">前端必知必会</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org454fd97">请描述一下 cookies sessionStorage和localstorage区别</a>
<ul>
<li><a href="#org1b62760">相同点：都存储在客户端</a></li>
<li><a href="#org8bf5f77">不同点：</a></li>
</ul>
</li>
<li><a href="#orgcd52f2b">javaScript有几种数据类型，其中基本数据类型有哪些</a></li>
<li><a href="#org755fce0">json 支持几种类型</a></li>
<li><a href="#org9b6b83a">undefined 和 null 区别</a></li>
<li><a href="#org8d8b86c">http 和 https 有何区别？如何灵活使用？</a></li>
<li><a href="#orgbc432bf">常见的HTTP状态码</a></li>
<li><a href="#orgd30f554">如何进行网站性能优化</a></li>
<li><a href="#org1c2a998">react和vue有哪些不同，说说你对这两个框架的看法</a>
<ul>
<li><a href="#org56fd053">相同点</a></li>
<li><a href="#org3d77aec">不同点</a></li>
</ul>
</li>
<li><a href="#orgd7efa93">px和em的区别</a></li>
<li><a href="#org6d545a9">JS哪些操作会造成内存泄露</a></li>
<li><a href="#org1a04f5d">关于JS事件冒泡与JS事件代理（事件委托）</a></li>
<li><a href="#orgef9419c">什么是闭包，如何使用它，为什么要使用它？</a></li>
<li><a href="#org5246ddb">请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</a></li>
<li><a href="#orgbd1c389">请解释一下JavaScript的同源策略。</a></li>
</ul>
</div>
</div>

<div id="outline-container-org454fd97" class="outline-2">
<h2 id="org454fd97">请描述一下 cookies sessionStorage和localstorage区别</h2>
<div class="outline-text-2" id="text-org454fd97">
</div>
<div id="outline-container-org1b62760" class="outline-3">
<h3 id="org1b62760">相同点：都存储在客户端</h3>
</div>

<div id="outline-container-org8bf5f77" class="outline-3">
<h3 id="org8bf5f77">不同点：</h3>
<div class="outline-text-3" id="text-org8bf5f77">
<p>
1.存储大小:
</p>

<ul class="org-ul">
<li>cookie数据大小不能超过4k。</li>
<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
</ul>

<p>
2.有效时间
</p>

<ul class="org-ul">
<li>localStorage  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li>
<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>数据与服务器之间的交互方式: cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端; sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcd52f2b" class="outline-2">
<h2 id="orgcd52f2b">javaScript有几种数据类型，其中基本数据类型有哪些</h2>
<div class="outline-text-2" id="text-orgcd52f2b">
<p>
五种基本类型: Undefined、Null、Boolean、Number和String。
</p>

<p>
1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。
</p>

<p>
Object、Array和Function则属于引用类型
</p>
</div>
</div>

<div id="outline-container-org755fce0" class="outline-2">
<h2 id="org755fce0">json 支持几种类型</h2>
<div class="outline-text-2" id="text-org755fce0">
<ul class="org-ul">
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>null</li>
</ul>
</div>
</div>

<div id="outline-container-org9b6b83a" class="outline-2">
<h2 id="org9b6b83a">undefined 和 null 区别</h2>
<div class="outline-text-2" id="text-org9b6b83a">
<p>
null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。
</p>

<p>
undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。
</p>

<p>
null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。
</p>

<p>
javaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。
</p>
</div>
</div>

<div id="outline-container-org8d8b86c" class="outline-2">
<h2 id="org8d8b86c">http 和 https 有何区别？如何灵活使用？</h2>
<div class="outline-text-2" id="text-org8d8b86c">
<p>
http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
</p>

<p>
https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份
</p>
</div>
</div>

<div id="outline-container-orgbc432bf" class="outline-2">
<h2 id="orgbc432bf">常见的HTTP状态码</h2>
<div class="outline-text-2" id="text-orgbc432bf">
<pre class="example">
2开头 （请求成功）表示成功处理了请求的状态代码。

200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201   （已创建）  请求成功并且服务器创建了新的资源。
202   （已接受）  服务器已接受请求，但尚未处理。
203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。
204   （无内容）  服务器成功处理了请求，但没有返回任何内容。
205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206   （部分内容）  服务器成功处理了部分 GET 请求。

3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。

400   （错误请求） 服务器不理解请求的语法。
401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403   （禁止） 服务器拒绝请求。
404   （未找到） 服务器找不到请求的网页。
405   （方法禁用） 禁用请求中指定的方法。
406   （不接受） 无法使用请求的内容特性响应请求的网页。
407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408   （请求超时）  服务器等候请求时发生超时。
409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。
411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
415   （不支持的媒体类型） 请求的格式不受请求页面的支持。
416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
417   （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

500   （服务器内部错误）  服务器遇到错误，无法完成请求。
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

</pre>
</div>
</div>

<div id="outline-container-orgd30f554" class="outline-2">
<h2 id="orgd30f554">如何进行网站性能优化</h2>
<div class="outline-text-2" id="text-orgd30f554">
<ol class="org-ol">
<li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li>

<li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li>
</ol>

<p>
总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。
</p>

<p>
前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。
</p>

<p>
一、页面级优化
</p>
<p class="verse">
1. JavaScript 压缩和模块打包<br>
2. 按需加载资源<br>
3. 在使用 DOM 操作库时用上 array-ids<br>
4. 缓存<br>
5. 启用 HTTP/2<br>
6. 应用性能分析<br>
7. 使用负载均衡方案<br>
8. 为了更快的启动时间考虑一下同构<br>
9. 使用索引加速数据库查询<br>
10. 使用更快的转译方案<br>
11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染<br>
12. 用于未来的一个建议：使用 service workers + 流<br>
13. 图片编码优化<br>
</p>
</div>
</div>

<div id="outline-container-org1c2a998" class="outline-2">
<h2 id="org1c2a998">react和vue有哪些不同，说说你对这两个框架的看法</h2>
<div class="outline-text-2" id="text-org1c2a998">
</div>
<div id="outline-container-org56fd053" class="outline-3">
<h3 id="org56fd053">相同点</h3>
<div class="outline-text-3" id="text-org56fd053">
<ul class="org-ul">
<li>都支持服务器端渲染</li>
<li>都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范</li>
<li>数据驱动视图</li>
<li>都有支持native的方案,React的React native,Vue的weex</li>
</ul>
</div>
</div>

<div id="outline-container-org3d77aec" class="outline-3">
<h3 id="org3d77aec">不同点</h3>
<div class="outline-text-3" id="text-org3d77aec">
<ul class="org-ul">
<li>React严格上只针对MVC的view层,Vue则是MVVM模式</li>
<li>virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>
<li>组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;</li>
<li>数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</li>
<li>state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd7efa93" class="outline-2">
<h2 id="orgd7efa93">px和em的区别</h2>
<div class="outline-text-2" id="text-orgd7efa93">
<p>
px表示像素 (计算机屏幕上的一个点：1px = 1/96in)，是绝对单位，不会因为其他元素的尺寸变化而变化；
</p>

<p>
em表示相对于父元素的字体大小。em是相对单位 ，没有一个固定的度量值，而是由其他元素尺寸来决定的相对值。
</p>
</div>
</div>

<div id="outline-container-org6d545a9" class="outline-2">
<h2 id="org6d545a9">JS哪些操作会造成内存泄露</h2>
<div class="outline-text-2" id="text-org6d545a9">
<p>
1）意外的全局变量引起的内存泄露
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">leak</span><span style="color: #AE81FF;">(){</span>

  leak=<span style="color: #E6DB74;">"xxx"</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">leak&#25104;&#20026;&#19968;&#20010;&#20840;&#23616;&#21464;&#37327;&#65292;&#19981;&#20250;&#34987;&#22238;&#25910;</span>

<span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
2）闭包引起的内存泄露
</p>

<p>
3）没有清理的DOM元素引用
</p>

<p>
4）被遗忘的定时器或者回调 5）子元素存在引起的内存泄露
</p>
</div>
</div>

<div id="outline-container-org1a04f5d" class="outline-2">
<h2 id="org1a04f5d">关于JS事件冒泡与JS事件代理（事件委托）</h2>
<div class="outline-text-2" id="text-org1a04f5d">
<p>
 事件作为DOM操作重要的一环，需要大家好好理解和运用，今天特意看了一下事件冒泡和事件代理的相关资料，感触颇深，也深感自己的无知不知道多浪费了多少内存，废话不多说进入正题：
</p>

<p>
1.事件冒泡：
</p>

<p>
      通俗易懂的来讲，就是当一个子元素的事件被触发的时候（如onclick事件），该事件会从事件源（被点击的子元素）开始逐级向上传播，触发父级元素的点击事件。
</p>

<p>
2.事件委托
</p>

<p>
    事件委托，首先按字面的意思就能看你出来，是将事件交由别人来执行，再联想到上面讲的事件冒泡，是不是想到了？对，就是将子元素的事件通过冒泡的形式交由父元素来执行。下面经过详细的例子来说明事件委托：
</p>

<p>
有可能在开发的时候会遇到这种情况：如导航每一个栏目都要加一个事件，你可能会通过遍历来给每个栏目添加事件：
</p>
</div>
</div>

<div id="outline-container-orgef9419c" class="outline-2">
<h2 id="orgef9419c">什么是闭包，如何使用它，为什么要使用它？</h2>
<div class="outline-text-2" id="text-orgef9419c">
<p>
包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。
</p>

<p>
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
</p>

<p>
使用闭包的注意点：
</p>

<p>
· 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
</p>

<p>
· 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
</p>
</div>
</div>

<div id="outline-container-org5246ddb" class="outline-2">
<h2 id="org5246ddb">请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</h2>
<div class="outline-text-2" id="text-org5246ddb">
<p>
JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。
</p>

<p>
AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！
</p>
</div>
</div>

<div id="outline-container-orgbd1c389" class="outline-2">
<h2 id="orgbd1c389">请解释一下JavaScript的同源策略。</h2>
<div class="outline-text-2" id="text-orgbd1c389">
<p>
在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-12-14 Mon 10:41</p>
</div>
</body>
</html>
